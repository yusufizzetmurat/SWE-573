Project Overview: The Hive
The Hive is a community-oriented service exchange platform using a TimeBank system (1 hour service = 1 TimeBank hour).

Backend: Django 5, DRF, Django Channels (WebSockets), PostgreSQL, Redis.

Frontend: React 18, TypeScript, Vite, TailwindCSS, Radix UI.

Infrastructure: Docker, Nginx.

Core Business Logic (CRITICAL)
1. TimeBank Economy & Roles

Unit: 1 Hour = 1 Credit.

Reciprocity Rule: If a user's balance > 10 hours, they are BLOCKED from posting new "Offers" (but can still receive).

Role Determination (Do not confuse this):

"Offer" Post: Post Creator = Provider | Interested User = Receiver.

"Want/Need" Post: Post Creator = Receiver | Interested User = Provider.

Flow: Hours always flow from Receiver â†’ Provider.

2. Transaction Lifecycle

Negotiation: Users chat via WebSocket.

Handshake: Provider initiates details (time/location).

Provision (Escrow): Upon Handshake approval, hours are deducted from Receiver's balance immediately and held in escrow.

Completion: Both parties must confirm completion.

Transfer: Escrowed hours are finalized to the Provider.

3. Privacy & Safety

GDPR: Strict compliance.

Maps: Never show exact coordinates for in-person services on the public map. Use generalized locations/neighborhoods.

Tech Stack & Conventions
Backend (Django)
Location: /backend/api

Style:

Use Type Hints for all functions (e.g., def calc(user: User) -> Decimal:).

Use transaction.atomic() for ANY operation involving TimeBank transfers or Handshake status changes.

Fat Models / Utils: Keep Views thin. Move logic to utils.py or Model methods.

Serializers: Use read_only_fields for auto-managed timestamps.

WebSockets:

Handled in consumers.py.

Use sync_to_async for DB operations within consumers.

Caching: Invalidate cache (Redis) explicitly when User Profile or Service data changes (cache_utils.py).

Frontend (React/TypeScript)
Location: /frontend/src

Style:

Strict TypeScript usage. No any.

Use Functional Components with Hooks.

TailwindCSS for styling.

State Management:

Use AuthContext for user session.

Use useWebSocket hook for real-time features.

Avoid Redux; use React Context + Local State.

API:

Use api-client.ts (Axios) for all HTTP requests.

Handle 401 token refresh automatically (implemented in interceptors).

Architecture & File Structure
Models: backend/api/models.py (User, Service, Handshake, TransactionHistory).

Views: backend/api/views.py (Use ModelViewSet where possible).

Utils: backend/api/utils.py (TimeBank logic lives here).

Components: frontend/src/components/ (UI Logic).

Lib: frontend/src/lib/ (API, Hooks, Types).

Development Workflow
Migrations: Always run make migrate after model changes.

Docker: All services run in containers. References to localhost in code should respect Docker networking (Redis is redis:6379 internally).

Testing:

Backend: python manage.py test

Frontend: Standard Vitest/Jest patterns.

Specific Coding Rules
Wikidata: All services must include semantic tags fetched from Wikidata.

Reputation: Feedback is categorical ("Punctual", "Helpful", "Kind"), NOT 1-5 stars.

Notifications: Trigger notifications on: Handshake Req, Acceptance, Cancellation, Completion, Chat Msg.

Common Pitfalls to Avoid
Do not perform TimeBank math using float. Always use Decimal.

Do not update timebank_balance without creating a corresponding TransactionHistory record.

Do not allow a user to confirm a handshake if they have a schedule conflict (check scheduled_time).

Git Commit Style
Write commit messages like a human developer, not AI:

- Keep subject line under 50 chars, lowercase after verb
- Use imperative mood: "add", "fix", "refactor" (not "Added", "Fixes")
- No periods at end of subject line
- Be specific but concise: "fix chat scroll on mobile" not "Fix scrolling behavior in chat component to handle mobile viewport"
- Group related changes into single commits
- Body (if needed): explain WHY, not WHAT

Good examples:
  - "add public chat to service detail"
  - "fix race condition in handshake approval"
  - "refactor search filters into strategy pattern"

Bad examples:
  - "Fix scrolling behavior in chat component to handle edge cases" (too verbose)
  - "Update files" (too vague)
  - "Fix bug." (uninformative)

NEVER USE EMOJIS.